---
layout:     post
title:      推荐算法：协作型过滤
subtitle:   
date:       2019-02-11
author:     VickeeX
header-img: img/post-bg-casual-1.jpeg
catalog: true
tags:
    - Recommendations
    - Collaborative Filtering
    - Similarity
---

<***集体智慧( Collective Intelligence)***: 从随机人群中进行数据的搜集、组合和分析，常用到机器学习算法和统计方法。>

<***机器学习(Machine Learning)***: 由算法推断出一组数据的属性相关信息，并借此预测未来可能出现的其他数据。归纳数据中的“模式”，利用所认定的出现于数据中的重要特征对数据进行训练并得到一个模型。>

<***协作型过滤(Collaborative Filtering)***: 对数据进行搜索，并找出所感兴趣的一部分数据。(如对“电影”进行偏好过滤)>
## 建立偏好数据
根据用户对物品的评分或相关操作(如"收藏"动作对应x分)建立数据。

## 相似度评价值
根据数据确定用户(物品)的相似程度，需要计算“相似度评价值”，以下介绍常用的两套简单体系：***欧几里得距离***，***皮尔逊相关度***。

#### 欧几里得距离
Euclidean Distance Score. 以经过用户一致评价的物品为坐标轴，将参与评价的用户绘制于图上，考察用户彼此间的距离远近。在”偏好空间“中，两者距离越近，相似度越高。
坐标空间可以是二维的，也可以是多维的(对多个物品的偏好进行相似度比较，每条坐标轴对应一个物品的评分)
|  | item1 | item2 | item3 |
| ------ | ------ | ------ | ------ |
| user1 | s11 | s12 | s13 |
| user2 | s21 | s22 | s23 |
如上表，user1和user2费别对Item1~3进行了评价，则user1和user2的欧几里得距离为：
```sim_distance = 1/( sum_of_squares) = 1/( (s11-s21)^2 + (s12-s22)^2 + (s13-s23)^2 )  ```
即方差和的倒数。若两人评分完全一致，则上述公式值为无穷大，故常将方差和+1再求倒，即：```sim_distance = 1/( 1 + sum_of_squares)```

#### 皮尔逊相关度
皮尔逊相关度是判断两组数据与某一直线拟合程度的一种度量。
以用户评分作为坐标轴，将物品绘制于坐标空间中，绘制一条最佳拟合线。若两人评分情况相同，则最佳拟合线为对角线，相关度为1。此方法对“夸大分值”（如：user1比user2更倾向于给出更高的评价，或user1评分更严格给出的分数评价都偏低）进行了修正。算法计算过程如下：
```sum1 = s11+s12+s13 ;  sum2 = s21+s22+s23  // 和``` 
```sum1_sqrt = s11^2+s12^2+s13^2 ;  sum2_sqrt = s21^2+s22^2+s23^2  // 平方和```
```pSum = s11*s21 + s12*s22 + s13*s23  // 乘积之和```
```den = sqrt(  ( sum1_sqrt -  sum1^2 / n) *  ( sum2_sqrt -  sum2^2 / n) ) // 拟合度公式```
``` sim =  (pSum - sum1*sum2 / n) / den  //皮尔逊相似度 ```

#### 选择相似性度量方法
皮尔逊相关度在数据不规范（偏离很大）时倾向于给出比欧几里得距离更好的结果，但计算也更为复杂。
相似度的优劣取决于具体的应用，其他常用的相似度系数还有 Jaccard系数、曼哈顿距离等等。相似度计算函数满足共同的条件：以一个浮点数作为返回值，数值越大代表相似度越大。

## 基于用户/物品的过滤

* 基于用户的过滤 user_based collaborative filtering
计算用户间的相似度，选择相似度最大的用户进行偏好过滤（参照其偏好）。
根据 ```sim_score = sum(用户相似度*评价值) / sum(相似度) ```进行排序比较 。
* 基于物品的过滤 item_based collaborative filtering
根据用户评价过的物品，计算与其相似的物品，进行推荐。
计算 ``` sim_score = sum(物品相似度*评价值) / sum(相似度)  ```进行排序推荐。

针对大数据集生成推荐列表时，基于物品的过滤明显计算速度更快，但需要额外维护物品相似度表。对于稀疏数据集，item_based通过更优；对于密集数据集，效果几乎一样。user_based则更易于实现，但每次推荐时都会将某位用户与其他的进行比较，效率较低下，通常适用于规模较小的变化非常频繁的内存数据集。


